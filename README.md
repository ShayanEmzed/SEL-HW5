# SEL-HW5
آشنایی با پروفایلینگ و بررسی مصرف منابع
## بخش عملی
### سوال اول
پس از نصب yourkit و اجرای آن بر روی کلاس JavaCup می‌توانیم نحوه مصرف منابع توسط توابع مختلف را مشاهده کنیم:

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/b8ad4748-1a32-442f-89bd-b6d6dadad58e">

در پایین تصویر می‌توان دید که تابع temp بیشترین منبع را مصرف کرده است. (برنامه در سیستم من به علت کمبود مموری به اکسپشن RunOutOfMemory در هیپ خورده و پس از جلو رفتن در تابع temp اگزکیوت می‌شود. پس به تابع eval نمی‌رسیم که انتهای نمودار نزولی باشد.)  
برای حل این مشکل از تابع دو بعدی استفاده می‌کنیم تا سر بار اضافه کردن به انتهای لیست را کاهش دهیم:

<img width="387" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/8678382b-f8f0-49e4-b7ae-ba9c1a508d17">

می‌بینیم که مصرف منابع کاهش یافته است:

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/0dee9ceb-7125-446e-8136-66415352612b">

### سوال دوم
مسئله: گزارش رشته کلمات تکراری موجود در یک لیست
ورودی: یک لیست بزرگ (آرگیومنت numberOfStrings در generateRandomStrings) از کلمات ۵ حرفی شامل اعداد و حروف بزرگ انگلیسی
خروجی: پرینت رشته‌هایی که حداقل دوبار تکرار شده‌اند +‌ تعداد کل رشته‌های تکرار شده در انتها

ابتدا کد غیر بهینه در فایل NaiveMain را بررسی می‌کنیم. در هر دو ورژن بهینه و غیر بهینه دو تابع generateRandomStrings و manualInit را داریم. در اولی رشته‌های رندوم ایجاد کرده و در دومی به صورت دستی رشته به لیست اضافه می‌کنیم تا از صحت کد مطمئن شویم. میتوانید با کامنت کردن خطوط شش یا هفت فایل از هر کدام از این دو تابع استفاده کنید. برای مشاهده عملکرد و مصرف منابع، باید از اولی استفاده کنیم تا تعداد رشته‌ها زیاد باشد.  
در الگوریتم اول، برای تشخیص تکراری بودن دوبار بر روی لیست اصلی لوپ می‌زنیم، پس از یافتن عنصر تکراری، آرایه دیگری بدون اضافه کردن رشته تکراری یافت شده ایجاد می‌کنیم و این آرایه جدید را به عنوان لیست جدید در نظر می‌گیریم.
نحوه استفاده از منابع مثل cpu و مموری را می‌توانیم در yourkit مشاهده کنیم:

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/36956cdf-e548-47c3-9f2c-ed0b6044d29b">

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/a9ea0cc3-3a07-4541-b1ff-2f6458b55cf9">

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/1f751195-b19c-451d-976c-3a55f0f5b00d">

اما لازم نیست برای حذف کردن عنصر تکراری از لیست قبلی، لیست جدیدی ایجاد کنیم! بلکه می‌توان با استفاده از iterator بدون مشکل در iteration عنصر تکراری را حذف کرد. پس خطوط ۲۸ تا ۳۱ کد اصلی را تغییر داده و برای منابع خواهیم داشت (کد در فایل OptimizedMain):

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/762986da-5cfc-496d-8fef-f4b63ce3900d">

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/a5404398-1c5b-47d9-a3a6-e51e1f29353e">

<img width="1395" alt="image" src="https://github.com/ShayanEmzed/SEL-HW5/assets/60621655/bf6e2a1c-6da5-4fbf-9282-27ace7b18e17">

همانطور که مشاهده می‌شود با اینکه مموری استفاده شده افزایش کمی داشته، مصرف cpu به شدت کاهش پیدا کرده است.

